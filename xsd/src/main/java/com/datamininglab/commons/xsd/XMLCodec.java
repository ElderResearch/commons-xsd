package com.datamininglab.commons.xsd;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.sax.SAXSource;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

/**
 * XML reader and writer using code generated by JAXB. This will read and write
 * your root element to and from XML files or streams.
 * 
 * @author <a href="mailto:dimeo@datamininglab.com">John Dimeo</a>
 * @since Jan 15, 2016
 * @param <T> the root element type
 */
public class XMLCodec<T> {
	private Class<T> c;
	private JAXBContext context;
	
	/**
	 * Create a new codec.
	 * @param c the root element class
	 * @throws IOException if there was a problem instantiating the JAXB context
	 */
	public XMLCodec(Class<T> c) throws IOException {
		this.c = c;
		try {
			context = JAXBContext.newInstance(c);
		} catch (JAXBException e) {
			throw new IOException(e);
		}
	}
	
	/**
	 * Load and parse the contents of an XML file to a new root element instance.
	 * @param f the file to parse
	 * @return the parsed root element
	 * @throws IOException if there was a problem parsing the file
	 */
	public T load(File f) throws IOException {
		try (FileInputStream fis = new FileInputStream(f);
		     InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8)) {
			InputSource src = new InputSource(isr);
			src.setSystemId(f.getAbsolutePath());
			return load(src);
		}
	}
	
	/**
	 * Load and parse the contents of an XML input source to a new root element instance.
	 * Ensure that the source has a valid system ID if you use relative paths in
	 * your XML.
	 * @param src the source to parse
	 * @return the parsed root element
	 * @throws IOException if there was a problem parsing the source
	 */
	public T load(InputSource src) throws IOException {
		Unmarshaller um;
		XMLReader xr;
		try {
			um = context.createUnmarshaller();
			
			SAXParserFactory spf = SAXParserFactory.newInstance();
			spf.setValidating(true);
			spf.setXIncludeAware(true);
			spf.setNamespaceAware(true);
			
			xr = spf.newSAXParser().getXMLReader();
			return um.unmarshal(new SAXSource(xr, src), c).getValue();
		} catch (JAXBException | SAXException | ParserConfigurationException e) {
			throw new IOException(e);
		}
	}
	
	/**
	 * Save the root element to a file.
	 * @param elem the root element to save
	 * @param f the destination file
	 * @throws IOException if there was a problem saving the file
	 */
	public void save(JAXBElement<T> elem, File f) throws IOException {
		saveToFile(elem, f);
	}
	
	/**
	 * Save the root element to a file. Note that the type <tt>T</tt> must
	 * have been generated with a {@link XmlRootElement} annotation to use
	 * this method. Otherwise, use the generated <tt>ObjectFactory.create...()</tt>
	 * method to wrap your element first and use {@link #save(JAXBElement, File)}
	 * instead.
	 * @param elem the root element to save
	 * @param f the destination file
	 * @throws IOException if there was a problem saving the file
	 */
	public void save(T elem, File f) throws IOException {
		saveToFile(elem, f);
	}
	
	/**
	 * Save the root element to an output stream.
	 * @param elem the root element to save
	 * @param f the destination output stream
	 * @throws IOException if there was a problem saving to the output stream
	 */
	public void save(JAXBElement<T> elem, OutputStream os) throws IOException {
		saveToStream(elem, os);
	}

	/**
	 * Save the root element to an output stream. Note that the type <tt>T</tt> must
	 * have been generated with a {@link XmlRootElement} annotation to use
	 * this method. Otherwise, use the generated <tt>ObjectFactory.create...()</tt>
	 * method to wrap your element first and use {@link #save(JAXBElement, OutputStream)}
	 * instead.
	 * @param elem the root element to save
	 * @param os the destination output stream
	 * @throws IOException if there was a problem saving to the output stream
	 */
	public void save(T elem, OutputStream os) throws IOException {
		saveToStream(elem, os);
	}
	
	private void saveToFile(Object elem, File f) throws IOException {
		try (FileOutputStream fos = new FileOutputStream(f)) {
			saveToStream(elem, fos);
		}
	}
	
	private void saveToStream(Object elem, OutputStream os) throws IOException {
		try {
			Marshaller m = context.createMarshaller();
			customizeMarshaller(m);
			m.marshal(elem, new OutputStreamWriter(os, StandardCharsets.UTF_8));
		} catch (JAXBException e) {
			throw new IOException(e);
		}
	}
	
	/**
	 * Customize (set properties on) the marshaller used by this codec. By default,
	 * formatting ("pretty printing") is turned on.
	 * @param m the marshaller
	 * @throws JAXBException if there was a problem customizing the marshaller
	 */
	protected void customizeMarshaller(Marshaller m) throws JAXBException {
		m.setProperty(Marshaller.JAXB_ENCODING, "Unicode");
		m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
	}
}